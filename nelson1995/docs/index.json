

























[{"content":"A list of all the personal projects I\u0026rsquo;ve developed over a period of time. Order is just random and doesn\u0026rsquo;t depict popularity nor timeline.\n","description":null,"permalink":"http://localhost:1313/projects/","summary":"A list of all the personal projects I\u0026rsquo;ve developed over a period of time. Order is just random and doesn\u0026rsquo;t depict popularity nor timeline.","tags":null,"title":"Projects"},{"content":"Greetings, I\u0026rsquo;m Nelson Katale and I\u0026rsquo;m from Kampala, Uganda. This is my personal blog website which I use to document my learnings and share my pet projects to the world. All posts contains a list of posts I\u0026rsquo;ve documented here from the latest to the oldest. You can also click the Search to search for posts by specific keywords. You can find more about my professional experience on my LinkedIn profile.\n","description":null,"permalink":"http://localhost:1313/me/","summary":"Greetings, I\u0026rsquo;m Nelson Katale and I\u0026rsquo;m from Kampala, Uganda. This is my personal blog website which I use to document my learnings and share my pet projects to the world. All posts contains a list of posts I\u0026rsquo;ve documented here from the latest to the oldest. You can also click the Search to search for posts by specific keywords. You can find more about my professional experience on my LinkedIn profile.","tags":null,"title":"About me"},{"content":"A few years ago I had an old Laravel project that I built back in 2019. Back then I was still a junior developer and at that time I had no plans to host it. Fast forward to March 2024 I decided to host it in Heroku which I detailed in the last article .\nOne of my reasons for this post was to give a guide to help make the Laravel version upgrade experience as less time consuming, and straightforward as possible.\nBefore the deployment process l first skimmed through the docs and noticed that Heroku ended support for php 7 and this project runs on php 7.3. Easy I could just update the project dependencies by running this command below\n$ composer update and problem solved but here‚Äôs the problem a lot of these dependencies require a minimum dependency version in order for them to install. This can be solved by running\n$ composer update ‚Äîignore-platform-reqs However, this is a careless move as it can break the whole project. Below are the steps on how I carefully upgraded the project to Laravel 8. Make sure the php version 8 is installed in your workstation. You can check which version is installed by running\n$ php -v Open the composer.json file and in the require section modify the dependencies to match the below listed versions.\n- php:^8.0 - guzzlehttp/guzzle: ^7.0.1 - laravel/framework: ^8.0 - laravel/passport: ^10.4.2 - phpunit/phpunit: ^9.0 - facade/ignition: ^2.3.6 - nunomaduro/collision: ^5.0 - laravel/ui: ^3.0 After that open your terminal in your project root and run;\n$ composer update You might encounter some errors on terminal and so I‚Äôd advise you to search the package on packagist or look for it‚Äôs website to check which dependency version the package requires and modify accordingly.\nThere are new changes and styles introduced in Laravel 8. Follow these steps and modify accordingly.\nSeeders Rename the database/seeds directory to database/seeders. Now open each seeder class and add a namespace on top of the line like this\n\u0026lt;?php namespace Database\\Seeders; Factories Next in factories open each factory class and add this line\n\u0026lt;?php namespace Database\\Factories; Auto load seeder classes and factory clssses** Open your composer file and modify the section autoload to match this one below.\n{ ..., \u0026#34;autoload\u0026#34;: { \u0026#34;psr-4\u0026#34;: { \u0026#34;App\\\\\u0026#34;: \u0026#34;app/\u0026#34;, \u0026#34;Database\\\\Factories\\\\\u0026#34;: \u0026#34;database/factories/\u0026#34;, \u0026#34;Database\\\\Seeders\\\\\u0026#34;: \u0026#34;database/seeders/\u0026#34; } } } Routing Open the RouteServiceProvider.php and modify it to reflect the standard Laravel 8 RouteServiceProvider.php. Next update the routes in web.php and api.php files to match this style below;\nRoute::post(‚Äòregister‚Äô[RegisterController::class,‚Äòregister‚Äô])‚Üíname(‚Äòregister‚Äô); That‚Äôs it !\n","description":null,"permalink":"http://localhost:1313/posts/steps-to-upgrade-laravel-7-project-to-8/","summary":"A few years ago I had an old Laravel project that I built back in 2019. Back then I was still a junior developer and at that time I had no plans to host it. Fast forward to March 2024 I decided to host it in Heroku which I detailed in the last article .\nOne of my reasons for this post was to give a guide to help make the Laravel version upgrade experience as less time consuming, and straightforward as possible.","tags":null,"title":"Steps to upgrade Laravel 7 project to 8"},{"content":"Telegram Telegram is a cloud-based mobile and desktop messaging app with a focus on security and speed. It is free to use and extensively hackable. It also has a good bot support system. The API is also easy to implement and has many wrappers for building bots with the API.\nGitHub Actions GitHub Actions is a CI/CD runtime for your GitHub repository. You can run almost anything from scripts to docker containers. You can build, test and deploy your code with GitHub Actions. All these actions are called workflows and workflows differ in the job they\u0026rsquo;re doing. These maybe test workflows, build ones or deployment ones. You can find all the actions on GitHub in the marketplace\nBuilding the Bot Prerequisites Basic JavaScript Knowledge Basic GitHub Knowledge Telegram Account There are templates for building actions. Here we\u0026rsquo;re gonna start from scratch\nEnvironment Setup Node, You can download node from their website NPM comes with node, so you don\u0026rsquo;t have to worry about it. Initialize the Project $ git init ## initialize a new git repository for version management --- $ npm init dotenv, Dotenv can be downloaded via $ npm i dotenv --- $ yarn add dotenv node-telegram-bot-api, node-telegram-bot-api is a simple wrapper for building telegram bots. You can download it via $ npm i node-telegram-bot-api --- $ yarn add node-telegram-bot-api @zeit/ncc, NCC is a Simple CLI for compiling a Node.js module into a single file, together with all its dependencies, GCC-style. It\u0026rsquo;s a dev dependency and can be downloaded yarn add --dev @zeit/ncc --- npm i -D @zeit/ncc Folder Structure The dist folder will be automatically created. action.yml will be made\n. ‚îú‚îÄ‚îÄ dist ‚îÇ ‚îî‚îÄ‚îÄ index.js ‚îú‚îÄ‚îÄ index.js ‚îú‚îÄ‚îÄ action.yml ‚îú‚îÄ‚îÄ README.md ‚îî‚îÄ‚îÄ package.json index.js is the file we\u0026rsquo;re defining the bot action.yml is the file we\u0026rsquo;ll define the action and it\u0026rsquo;s behaviours Making the Bot We need to get an API bot token from telegram. For that Go to Telegram and Search for Botfather. It\u0026rsquo;s a bot. Create a new bot with the /newbot command and get the API key. We\u0026rsquo;ll need that, also talk to jsondump bot and get your chat id. The output may be like this, so\n{ \u0026#34;update_id\u0026#34;: 143943779, \u0026#34;message\u0026#34;: { \u0026#34;message_id\u0026#34;: 181575, \u0026#34;from\u0026#34;: { \u0026#34;id\u0026#34;: 123456 // this is what we need \u0026#34;is_bot\u0026#34;: false, \u0026#34;first_name\u0026#34;: \u0026#34;Tg Name\u0026#34;, \u0026#34;username\u0026#34;: \u0026#34;TG Username\u0026#34;, \u0026#34;language_code\u0026#34;: \u0026#34;en\u0026#34; }, \u0026#34;chat\u0026#34;: { \u0026#34;id\u0026#34;: 123456, \u0026#34;first_name\u0026#34;: \u0026#34;Tg Name\u0026#34;, \u0026#34;username\u0026#34;: \u0026#34;TG Username\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;private\u0026#34; }, \u0026#34;date\u0026#34;: 1584119424, \u0026#34;text\u0026#34;: \u0026#34;message\u0026#34; } } This will be needed for further use and We need to add it to the repo secrets which can be found in the repo settings. Be careful to add it as token and chat like as shown below Writing the Action and Building the Bot Fire up the terminal/cmd and make a new folder. Install the dependencies. Run the following command\n$ touch index.js action.yml Open your favourite text editor within the folder or with the file. We\u0026rsquo;ll define the bot in index.js\nrequire(\u0026#34;dotenv\u0026#34;).config const Bot = require(\u0026#39;node-telegram-bot-api\u0026#39;); const { INPUT_STATUS: ipstatus, INPUT_TOKEN: tgtoken,//Telegram api token INPUT_CHAT: chatid,// Telegram Chat ID INPUT_IU_TITLE: ititle,// Issue title INPUT_IU_NUM: inum,// Issue Number INPUT_IU_ACTOR: iactor,// Issue made by INPUT_IU_BODY: ibody,// Issue Body INPUT_PR_NUM: pnum,// PR Number INPUT_PR_STATE: prstate,// PR Opened, reponed or closed INPUT_PR_TITLE: ptitle,// PR Title INPUT_PR_BODY: pbody,// Body of the PR GITHUB_EVENT_NAME: ghevent,// Name of the trigger event GITHUB_REPOSITORY: repo,// Repository the trigger was made from GITHUB_ACTOR: ghactor,// User who triggered the action GITHUB_SHA: sha,// Commit ID GITHUB_WORKFLOW: ghwrkflw// Workflow Name } = process.env; const bot = new Bot(tgtoken) First, we\u0026rsquo;re defining the dotenv for config and initializing Telegram Bot. Here we\u0026rsquo;re defining the alias variables for the environment variables. You might notice an INPUT_ for almost every environment variable, this is because GitHub Actions pass the env variable with an INPUT prefix. Other env variables are action\u0026rsquo;s default environment variables. Then we initialized the bot with the API token.\nGitHub actions could be triggered with Issues, Pull Request or Pushes. You can find the trigger events here. Here we\u0026rsquo;re gonna get a message from the bot when an Issue or Pull Request or a Push event has happened.\nconst evresp = (gevent) =\u0026gt; { switch (gevent) { case \u0026#34;issues\u0026#34;: return ` ‚ùóÔ∏è‚ùóÔ∏è‚ùóÔ∏è‚ùóÔ∏è‚ùóÔ∏è‚ùóÔ∏è Issue ${prstate} Issue Title and Number : ${ititle} | #${inum} Commented or Created By : \\`${iactor}\\` Issue Body : *${ibody}* [Link to Issue](https://github.com/${repo}/issues/${inum}) [Link to Repo ](https://github.com/${repo}/) [Build log here](https://github.com/${repo}/commit/${sha}/checks)` case \u0026#34;pull_request\u0026#34;: return ` üîÉüîÄüîÉüîÄüîÉüîÄ PR ${prstate} PR Number: ${pnum} PR Title: ${ptitle} PR Body: *${pbody}* PR By: ${ghactor} [Link to Issue](https://github.com/${repo}/pull/${pnum}) [Link to Repo ](https://github.com/${repo}/) [Build log here](https://github.com/${repo}/commit/${sha}/checks)` default: return ` ‚¨ÜÔ∏è‚áÖ‚¨ÜÔ∏è‚áÖ ID: ${ghwrkflw} Action was a *${ipstatus}!* \\`Repository: ${repo}\\` On: *${ghevent}* By: *${ghactor}* Tag: ${process.env.GITHUB_REF} [Link to Repo ](https://github.com/${repo}/) ` } } In these lines of code, we\u0026rsquo;re just initializing a switch statement for the responses. We\u0026rsquo;re also declaring an anonymous function to use the switch responses via a function later. We\u0026rsquo;re using all the defined variables in the switch. You can check the trigger Events to get how the event is triggered and what keyword should be used.\nNow for the last part of the Js file, we just take the response from the switch and assign it to a constant. Then we use the sendMessage function of the node-telegram-bot-api to send the message to the bot with the chatid and the output as the arguments.\nconst output = evresp(ghevent) bot.sendMessage(chatid,output,{parse_mode : \u0026ldquo;Markdown\u0026rdquo;})\nCompiling and Minifying the Js code Since we have installed @zeit/ncc and this is used for the making the whole program with all the APIs to a single file and we need to use NCC for that. We just need to run\nyarn run ncc build index.js -C -m -o dist or you might wanna add the following to you package.json file, and run npm run test to compile and minify the code.\n\u0026#34;scripts\u0026#34;: { \u0026#34;test\u0026#34;: \u0026#34;ncc build index.js -C -m -o dist\u0026#34; }, This will create a dist folder with and index.js file which contains the compiled code.\nMaking it a valid action For making this Js file a valid action, we need to add an action.yml file. The action.yml for this action is like this\nname: \u0026#39;Action Name\u0026#39; description: \u0026#39;Action Descreption\u0026#39; author: \u0026#39;\u0026lt;author name\u0026gt;\u0026#39; inputs: chat: description: \u0026#39;Chat to send: chat id or @channel_name\u0026#39; required: true token: description: \u0026#39;Telegram Bot token\u0026#39; required: true status: description: \u0026#39;Job status\u0026#39; required: true iu_title: description: \u0026#39;Issue Title\u0026#39; default: ${{ github.event.issue.title }} iu_num: description: \u0026#39;Issue Number\u0026#39; default: ${{ github.event.issue.number }} iu_actor: description: \u0026#39;Issue Triggerer\u0026#39; default: ${{ github.event.issue.user.login }} iu_com: description: \u0026#39;Issue Comment\u0026#39; default: ${{github.event.comment.body}} pr_state: description: \u0026#39;State of the PR\u0026#39; default: ${{ github.event.action }} pr_num: description: \u0026#39;PR Number\u0026#39; default: ${{ github.event.number }} pr_title: description: \u0026#39;Title of the PR\u0026#39; default: ${{ github.event.pull_request.title }} pr_body: description: \u0026#39;Body/Contents of the PR\u0026#39; default: ${{ github.event.pull_request.body }} runs: using: \u0026#34;node12\u0026#34; main: \u0026#34;dist/index.js\u0026#34; branding: icon: \u0026#39;repeat\u0026#39; color: \u0026#39;green\u0026#39; Here we\u0026rsquo;re defining the Input variables to be loaded for the action in GitHub\u0026rsquo;s runtime environemt. All these default data are taken from the response of the webhooks which are send by GitHub when a trigger event is occured. You can find out more in the Action Documentation Here.\nruns: using: \u0026#34;node12\u0026#34; main: \u0026#34;dist/index.js\u0026#34; Here we are defining that this is a node action and should run in an environment with node, and the file which should be run, here the index.js file in the dist folder. That should do it. Create a new commit and push it to a repo. Create a new tag and this action will appear in the marketplace.\nDefining a workflow to test your action GitHub Action workflows are defined using the .yml syntax. Here is an example of a sample workflow for this action\nname: \u0026lt;Workflow Name\u0026gt; on: push: pull_request: types: [opened, closed] issues: types: [opened, closed, reopened] jobs: build: runs-on: ubuntu-latest steps: - name: \u0026lt;AnyName\u0026gt; uses: \u0026lt;username\u0026gt;/\u0026lt;repo\u0026gt;@master if: always() with: chat: ${{ secrets.chat }} token: ${{ secrets.token }} status: ${{ job.status }} The Complete code for the bot is\n//Initializing dotenv and the bot require(\u0026#34;dotenv\u0026#34;).config const Bot = require(\u0026#39;node-telegram-bot-api\u0026#39;); // aliasing the environment variables const { INPUT_STATUS: ipstatus, INPUT_TOKEN: tgtoken, //Telegram api token INPUT_CHAT: chatid,// Telegram Chat ID INPUT_IU_TITLE: ititle,// Issue title INPUT_IU_NUM: inum,// Issue Number INPUT_IU_ACTOR: iactor, // Issue made by INPUT_IU_BODY: ibody, // Issue Body INPUT_PR_NUM: pnum, // PR Number INPUT_PR_STATE: prstate, // PR Opened, reponed or closed INPUT_PR_TITLE: ptitle, // PR Title INPUT_PR_BODY: pbody, // Body of the PR GITHUB_EVENT_NAME: ghevent, // Name of the trigger event GITHUB_REPOSITORY: repo, // Repository the trigger was made from GITHUB_ACTOR: ghactor, // User who triggered the action GITHUB_SHA: sha, // Commit ID GITHUB_WORKFLOW: ghwrkflw // Workflow Name } = process.env; const bot = new Bot(tgtoken) // Function to return the response for the specific trigger const evresp = (gevent) =\u0026gt; { switch (gevent) { //Switch statement for issues case \u0026#34;issues\u0026#34;: return ` ‚ùóÔ∏è‚ùóÔ∏è‚ùóÔ∏è‚ùóÔ∏è‚ùóÔ∏è‚ùóÔ∏è Issue ${prstate} Issue Title and Number : ${ititle} | #${inum} Commented or Created By : \\`${iactor}\\` Issue Body : *${ibody}* [Link to Issue](https://github.com/${repo}/issues/${inum}) [Link to Repo ](https://github.com/${repo}/) [Build log here](https://github.com/${repo}/commit/${sha}/checks)` // Switch statement for Pull Requests case \u0026#34;pull_request\u0026#34;: return ` üîÉüîÄüîÉüîÄüîÉüîÄ PR ${prstate} PR Number: ${pnum} PR Title: ${ptitle} PR Body: *${pbody}* PR By: ${ghactor} [Link to Issue](https://github.com/${repo}/pull/${pnum}) [Link to Repo ](https://github.com/${repo}/) [Build log here](https://github.com/${repo}/commit/${sha}/checks)` default: // switch statement for Pushes return ` ‚¨ÜÔ∏è‚áÖ‚¨ÜÔ∏è‚áÖ ID: ${ghwrkflw} Action was a *${ipstatus}!* \\`Repository: ${repo}\\` On: *${ghevent}* By: *${ghactor}* Tag: ${process.env.GITHUB_REF} [Link to Repo ](https://github.com/${repo}/) ` } } // assigning the output to a variable const output = evresp(ghevent) // sending the message bot.sendMessage(chatid,output,{parse_mode : \u0026#34;Markdown\u0026#34;}) You can try out many different items using actions and this is just a sample action to get you started. Maybe sending Cat GIFs if the build succeded on the pull request or sending a welcome message to a first time contributor. You imagination is the limitüòÑ and Never Stop being ‚ö°Ô∏è\n","description":"Make a Telegram bot with Node.js and use it with GitHub Actions for sending notifications to you about the repo.","permalink":"http://localhost:1313/posts/tg-gh/","summary":"Telegram Telegram is a cloud-based mobile and desktop messaging app with a focus on security and speed. It is free to use and extensively hackable. It also has a good bot support system. The API is also easy to implement and has many wrappers for building bots with the API.\nGitHub Actions GitHub Actions is a CI/CD runtime for your GitHub repository. You can run almost anything from scripts to docker containers.","tags":null,"title":"Telegram Bot for  GitHub Actions"},{"content":"I‚Äôm sure you have ever come across the term type checking, either static or dynamic type checking while reading a textbook about your favorite programming language or during the late afternoon programming lectures and you probably didn‚Äôt fully understand what it meant. Evening lecture on programming The problem is that some articles have failed to give a clear explanation on what type checking is and the different types but after doing some research and studying of my own, I‚Äôve decided to write a concise article to help you gain a clear understanding of what type checking means and its different types. Type checking verifies and enforces constraints on the type of a variable with the aim of keeping the type errors to a minimum. Type checking ensures that the program is type safe as type errors can occur while the program is running .\nExample 1 python 3 Above is a python program attempting to add 2 to a string. Adding an integer to a string results into a type error since the expression is not meant to handle multiple data types. As a result, it throws a type error which stops the program from executing.\nUnder type checking, we have static and dynamic type checking. The key difference between the two is that with static type checking, the type of variable is known at compile time (it checks the type of variable before running) while with dynamic type checking, the type of variable is known at runtime (it checks the type of variable while executing). Compiled programming languages such as C++ and Java are fast because the compiler knows the exact data types used when the variable is initialized which results into optimized code that runs faster and uses less memory. Dynamic type checking results into less optimized code and runtime type error which is likely to occur since it forces runtime checks every time the program executes.\nNote: Not all static typed languages are exclusively strongly typed or weakly typed. The same applies to dynamic typed languages.\nStrongly typed languages: the type of variable is bound to a specific data type. Most static typed checking languages are strongly typed because the datatype is defined when initializing a variable. Dynamic typed languages are also strongly typed but they use type inference (where the type of variable is determined from the value it holds) to define the datatype of the variable.\nWeakly typed languages: their variable type isn‚Äôt bound to a specific data type. The variables have a type but its type constraint is lower than that of a strongly typed programming languages.\nExample 2\nphp The above PHP script adds 2 to a string variable called ‚Äú word ‚Äù but it outputs 2.\nThink of strongly type languages as having a high degree of type safety and weakly typed languages as having a low degree.\nLinks:\nType system - Wikipedia\n","description":null,"permalink":"http://localhost:1313/posts/static-type-checking-and-dynamic-type-checking/","summary":"I‚Äôm sure you have ever come across the term type checking, either static or dynamic type checking while reading a textbook about your favorite programming language or during the late afternoon programming lectures and you probably didn‚Äôt fully understand what it meant. Evening lecture on programming The problem is that some articles have failed to give a clear explanation on what type checking is and the different types but after doing some research and studying of my own, I‚Äôve decided to write a concise article to help you gain a clear understanding of what type checking means and its different types.","tags":null,"title":"Static Type Checking and Dynamic Type Checking"}]
